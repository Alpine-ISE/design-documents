# How to support external and/or large configuration files

## Context

Kubernetes has a maximum ConfigMap size of 1MB. Some applications require larger configuration or data files.

Another common scenario is configuration files which have a lifecycle independent of the application module (container image) run on Kubernetes.  For example, if the configuration files are generated by an external system.

It is also desirable that when such configuration files are modified, a pod-restart is **not** required.

<br>

## Problem

We need a means to use external and/or large configuration files which:

* can accommodate files at least 2MB in size with no restrictions in format (binary, text, etc) though likely to be JSON.
* is compatible with the GitOps approach of changes being pulled (as opposed to pushed) to the cluster.
* preferably committed to the same GitOps repository, so that it's easy to find (i.e. all in one place) - for configuration as code.

<br>

## Options which can be immediately discounted:

Kubernetes provides several mechanisms for managing external files, but many of these do not meet our basic requirements:

1. [Copying files with `kubectl cp`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#cp) - however, it is an imperative approach and would require pipelines to push the files.
2. [Using Helm Files](https://helm.sh/docs/chart_template_guide/accessing_files/) but Helm charts must also "be smaller than 1M because of the storage limitations of Kubernetes objects."   Helm does support [storage backends](https://helm.sh/docs/topics/advanced/#storage-backends) which can include databases but this adds what we feel to be unnecessary complexity.
3. [Kubernetes Persistent volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) - the default storage classes in AKS support Azure Disk and Azure Files for persistence of files. The files could either be fetched onto the cluster by a CSI driver or via a custom script. The CSI drivers ([blob](https://github.com/kubernetes-sigs/blob-csi-driver) and [disk](https://github.com/kubernetes-sigs/azuredisk-csi-driver)) however do not include offline support, and hence are not suitable. The custom script would still be a more imperative approach of pushing configuration (unless used in combination with one of the following two mechanisms)

<br>

## Decision drivers

Key decision drivers:

1. Does not require restart of the pod on configuration change.
2. Resilience (failure proof) - mitigate the chance of a module being deployed without its configuration (e.g. if Internet connectivity is lost);
3. Ensure that the application will not run without its configuration. i.e. lifecycle of a module & its configuration file are coupled.
4. Minimal changes to the existing applications (i.e. no need for application developers to add functionality to specifically handle the configuration files, or falling back to a previous config if the latest version cannot be downloaded) making it easier to onboard contributed/third-party applications.
5. Ease of initial setup. (e.g. images, keys, pipelines etc).
6. Developer productivity - simple to understand, efficient dev-test loop.
7. Ease of maintenance.   (e.g. secret/key rotation)
8. Secure
9. Scalable to a large number of distinct files

<br>

## Options considered:

Options which have been considered:

1. Use [Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) to download (HTTP) or clone (Git) the external configuration file into a volume.

    > Because init containers run to completion before any app containers start, init containers offer a mechanism to block or delay app container startup until a set of preconditions are met. Once preconditions are met, all of the app containers in a Pod can start in parallel.

2. Bake the configuration into a separate container (from the actual application) and have it downloaded & mounted to a volume before the application workload starts. (Again using Init Containers)
3. Download from an external secure storage resource (e.g. Azure Storage Account) using credentials provided to the module.
4. Similar to Init Containers but running as a sidecar instead to download new configuration files without restarting the main application.


## Spike

- The [Init Containers documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/) literally shows option 4, downloading an external HTML file to be served by a second container running nginx.

  Example below shows cloning config from a repo:

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: init-demo
  spec:
    containers:
    - name: nginx
      image: nginx
      ports:
      - containerPort: 80
      volumeMounts:
      - name: workdir
        mountPath: /usr/share/nginx/html
    # These containers are run during pod initialization
    initContainers:
    - name: install
      image: alpine/git
      command:
      - git
      - clone
      - "https://github.com/username/examplerepo.git"
      - "/work-dir"
      volumeMounts:
      - name: workdir
      mountPath: "/work-dir"
    dnsPolicy: Default
    volumes:
    - name: workdir
      emptyDir: {}
  ```

Any credentials that are needed for the download can be fetched from Key Vault using the External Secrets Operator.
If the configuration is packed into the container image, no separate credentials are needed, saving some effort. Also any mechanisms to speed up image downloads or to handle offline scenarios for container images can be reused if the configuration file is packaged into the image.
  NB: use of Persistent Volumes will ensure that the configuration is cached locally & so that it can be loaded even if offline when restarted.


<br>

## Consequences of each approach on workflow

Sequence diagrams to consider the workflow and process for building applications & configuration artefacts.

**1. Init Container with config pulled from Storage Account**


Initial one-time setup:
* place Storage Account access key in Key Vault
* have ESO pull the Storage Account access key from Key Vault & make it available as a Secret on the cluster

Dev loop IF the large config files are created by the Application Developer:

(dotted lines indicate work performed by pipeline)

::: mermaid
 sequenceDiagram
    App Developer ->> App Repo: update large config file<br> (e.g. ML model) & version
    App Repo -->> Storage Account: push large config file
    App Developer ->> GitOps repo: add or update config version in /apps/<app>/<version> folder
:::



**2. Init Container with config baked into image**

When the large configuration file are generated by an external system (e.g. another module creating the config files), baking it into an image does not make sense.




## Evaluating the most viable options

Considering the options which pass the hygiene factors, and the extent to which they meet our key criteria (described in Decision Drivers):


| | Init Containers load config from git (repo) or https (storage account) | Init Containers with config file baked into an image | Application itself downloads from Storage Account |
|-|-----------|-----------|-----------|
| Does not require module restart when file changes | <span style="color:red">no <br> init container requires restart.</span><br><br>Requires side car - possibly same module |  <span style="color:red">no <br> init container requires restart.</span><br> | <span style="color:green">yes</span> |
| Resilient to intermittent network |  <span style="color:orange">less</span> | <span style="color:green">yes</span> | <span style="color:orange">less</span>  |
| Ensures module doesn't run if config not loaded (on first run) | <span style="color:green">yes</span> | <span style="color:green">yes</span> | <span style="color:red">no <br> |
| Ease of setup | <span style="color:orange">medium</span>| <span style="color:red">the most work</span> <br>(setting up config build, and Kubernetes manifest, incl. when deleted) | ? <br>(update code to recover or die if config can't be downloaded) |
| Developer productivity | <span style="color:green">ok</span> | <span style="color:green">ok</span> | <span style="color:red">hardest</span> <br>(storage account key management) |
| Ease of maintenance | Config files in storage account. | <span style="color:red">worst</span> <br>ACR gets full of old config images. <br>Risk of rebuilding images if base image non-compliant. | Config files in storage account. |


As you can see, there is no straightforward obvious "winner", and it really depends on what's simplest for your given scenario.
